# Chapter 2 Review Questions

Name: Vamshi Krishna Kurupati

Course: 5143 Operating Systems

Date: 17 Feb 2016.


##1. What are three objectives of an OS design?

  **Convenience**: An OS makes a computer more convenient to use.

  **Efficiency**: An OS allows the computer system resources to be used in an efficient manner.

  **Ability to evolve**: An OS should be constructed in such a way as to permit the effective development, testing,
  
  and introduction of new system functions without interfering with service.

##2. What is the kernel of an OS?
  The kernel is a fundamental part of a modern computer's OS.It is a computer program that manages input/output requests from           software, and translates them into data processing instructions for the central processing unit and other electronic components of a   computer.
  
  Functions of the kernel:
  
  **Memory Management**
  
  **Device Management**
  
  **Sysytem Calls**.

##3. What is multiprogramming?
 When two or more programs are residing in memory at the same time, then sharing the processor is referred to the multiprogramming.
Multiprogramming assumes a single shared processor. Multiprogramming increases CPU utilization by organizing jobs so that the CPU always has one to execute. High and efficient CPU utilization. User feels that many programs are allotted CPU almost simultaneously.

##4.What is a process?
 A process can be defined in many ways. A process is a series of steps and decisions involved in the way work is completed. We may not realize it, but processes are everywhere and in every aspect of our leisure and work. Processes can exchange information or synchronize their operation through several methods of interprocess communication (IPC).

##5.How is the execution context of a process used by the OS? 
 It is also known as the process state. It is the Internal data , the operating system is able to supervise and control the process.
 
##6. List and briefly explain five storage management responsibilities of a typical OS?
   The five principal storage management responsibilities are:
   
**i)Process isolation**: The operating system must prevent independent processes from interfering with each other's memory, both data and instructions.

**ii) Automatic allocation and management**: Programs should be dynamically allocated across the memory hierarchy as required. Allocation should be transparent to the programmer. Thus,  the operating system can achieve efficiency by assigning memory to jobs only as needed.

**iii) Support of modular programming**: Programmers should be able to define program modules, and to create, destroy, and alter the size of modules dynamically.

**iv) Protection and access control**: Sharing of memory, at any level of the memory hierarchy, creates the potential for one program to address the memory space of another. This is desirable when sharing is needed by particular applications. At other times, it threatens the integrity of programs and even of the operating system itself. The operating system must allow portions of memory to be accessible in various ways by various users.

**v) Long-term storage**: it is a process whereby memory is stored for a long period of time even when the computer is switch off. It is stored in RAM.

##7.Explain the distinction between a real address and a virtual address?
 **Real Address**:An address which is loaded into the memory address register of the memory is referred to as Real address. It is a binary number in the form of logical high and low states on an address bus that corresponds to a particular cell of primary storage (also called main memory). Real addressing means that your program actually knows the real layout of RAM.
 
 **Virtual Address**:: An address that is generated by CPU is referred to as Virtual address. The set of all logical address generated by a program is a logical address space. The user program deals with logical address or these are generated by user (program). Virtual addressing has many benefits. It protects programs from crashing each other through poor pointer manipulation, etc. Because each program has its own distinct virtual memory set, no program can read another's data - this is both a safety and a security plus.
 
##8.Describe Round Robin Scheduling techniques?
 
 The round robin scheduling, processes are dispatched in a FIFO manner but are given a limited amount of CPU time called a time-slice or a quantum. If a process does not complete before its CPU-time expires, the CPU is preempted and given to the next process waiting in a queue. The preempted process is then placed at the back of the ready list. Round Robin Scheduling is preemptive (at the end of time-slice) therefore it is effective in time-sharing environments in which the system needs to guarantee reasonable response times for interactive.
 
##9.Explain the difference between a monolithic kernel and a microkernel?

**Monolithic kernel**:This is the older approach, of which UNIX, MS-DOS and the early Mac OS are typical represents of. It runs every basic system service like process and memory management, interrupt handling and I/O communication, file system, etc.  It is constructed in a layered fashion, built up from the fundamental process management up to the interfaces to the rest of the operating system. The inclusion of all basic services in kernel space has three big drawbacks.
 
The Kernel size increase.

Lack of extensibility.

 The bad maintainability.
  
 **Microkernel**:The concept was to reduce the kernel to basic process communication and I/O control, and let the other system services reside in user space in form of normal processes (as so called servers). There is a server for managing memory issues, one server does process management, and another one manages drivers, and so on. Because the servers do not run in kernel space anymore, so called ”con-text switches” are needed, to allow user processes to enter privileged mode (and to exit again). That way, the μ-kernel is not a block of system services anymore, but represents just several basic abstractions and primitives to control the communication between the processes and between a process and the underlying hardware. Because communication is not done in a direct way anymore, a message system is introduced, which allows independent communication and favours extensibility.
 
##10.What is multithreading?
Multithreading is a type of execution model that allows multiple threads to exist within the context of a process such that they execute independently but share their process resources. A thread maintains a list of information relevant to its execution including the priority schedule, exception handlers, a set of CPU registers, and stack state in the address space of its hosting process. Multithreading is also known as threading.

##11.List the key design issues for an SMP operating system?
**Simultaneous concurrent processes or threads**: Kernel routines need to be reentrant to allow several processors to execute the same kernel code simultaneously. 

**Scheduling**: Scheduling may be performed by any processor, so conflicts must be avoided. 

**Synchronization**: With multiple active processes having potential access to shared address spaces or shared I/O resources, care must be taken to provide effective synchronization.

**Memory Management**: Memory management on a multiprocessor must deal with all of the issues found on uniprocessor machines. There is a problem with the cache memories: Cache memories contain image of a portion of main memory. If a processor changes the contents of the main memory, these changes have to be recorded in the cache memories that contain an image of that portion of memory. This is known as cache coherence problem and is typically solved in hardware. 

**Reliability and fault tolerance**: The operating system should provide graceful degradation in the face of processor failure.


 

 
  
  
  
  
